## Bitmask
* 더 빠른 수행시간 : 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 적절히 사용할 경우 다른 자료 구조를 사용하는 것 보다
훨씬 빨리 동작한다. 비트마스크 연산을 사용할 수 있다는 것은 원소의 개수가 많지 않다는 것을 의미하기 때문에, 엄청난 계산속도의 향상을
기대할 수는 없지만, 이러한 연산을 반복적으로 시행할 시에는, 작은 최적화도 큰 계산속도의 향상을 불러올 수 있다.
* 더 간결한 코드 : 다양한 집합 연산들은 반복문 없이 한 줄에 쓸 수 있기 때문에, 비트마스크를 적절히 사용하면 굉장히 짧은 코드를 작성할 수 있다.
* 더 작은 메모리 사용량 : 데이터를 더 적은 메모리로 표현할 수 있다.

### 1) 비트마스크를 이용한 집합이 구현
#### 1-1 공집합과 꽉 찬 집합 구하기
```c
int fullPizza = (1 << 20) - 1;
```
#### 1-2 원소 추가
```c
toppings |= (1 << p);
```
#### 1-3 원소의 포함 여부 확인
```c
if(toppings & (1 << p))
  return 1;
```
#### 1-4 원소의 삭제
```c
toppings &= ~(1 << p);
```
#### 1-5 원소의 토글
```c
toppings ^= (1 << p);
```
#### 1-6 최소 원소의 지수 구하기
```c
int firstToppings = (toppings & -toppings);
```
#### 1-7 최소 원소 지우기
```c
toppings &= (toppings - 1);
```


